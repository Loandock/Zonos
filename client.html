<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zonos Streaming TTS Client</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        textarea {
            width: 100%;
            height: 100px;
            margin-bottom: 10px;
        }
        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            margin-right: 10px;
        }
        button:disabled {
            background-color: #cccccc;
        }
        .status {
            margin-top: 20px;
            padding: 10px;
            background-color: #f0f0f0;
        }
        #audioContainer {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Zonos Streaming TTS</h1>
    
    <div>
        <label for="textInput">Type text to speak in real-time:</label>
        <textarea id="textInput" placeholder="Start typing to generate speech..."></textarea>
    </div>
    
    <div>
        <label for="languageSelect">Language:</label>
        <select id="languageSelect">
            <option value="en-us">English (US)</option>
            <option value="fr-fr">French</option>
            <option value="de">German</option>
            <option value="ja">Japanese</option>
            <option value="cmn">Chinese (Mandarin)</option>
        </select>
    </div>
    
    <button id="startBtn">Start Session</button>
    <button id="endBtn" disabled>End Session</button>
    
    <div class="status" id="status">Ready</div>
    
    <div id="audioContainer"></div>
    
    <script>
        let socket;
        let audioQueue = [];
        let isPlaying = false;
        let audioContext;
        let currentAudioElement = null;
        let sessionActive = false;
        let lastSentText = "";
        let typingTimer;
        
        const startBtn = document.getElementById('startBtn');
        const endBtn = document.getElementById('endBtn');
        const textInput = document.getElementById('textInput');
        const languageSelect = document.getElementById('languageSelect');
        const statusDiv = document.getElementById('status');
        const audioContainer = document.getElementById('audioContainer');
        
        // Initialize audio context on user interaction
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        function connectWebSocket() {
            // Connect to the WebSocket server
            const wsUrl = 'ws://localhost:8765';
            socket = new WebSocket(wsUrl);
            
            socket.onopen = function() {
                statusDiv.textContent = 'Connected to server';
                startBtn.disabled = false;
            };
            
            socket.onclose = function() {
                statusDiv.textContent = 'Disconnected from server';
                startBtn.disabled = true;
                endBtn.disabled = true;
                sessionActive = false;
            };
            
            socket.onerror = function(error) {
                statusDiv.textContent = 'WebSocket error: ' + error.message;
                startBtn.disabled = true;
                endBtn.disabled = true;
                sessionActive = false;
            };
            
            socket.onmessage = function(event) {
                // Check if the message is JSON metadata or binary audio data
                if (typeof event.data === 'string') {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'metadata') {
                            statusDiv.textContent = `Generating audio for: "${data.text}"`;
                        } else if (data.type === 'end') {
                            statusDiv.textContent = 'Generation complete';
                        } else if (data.type === 'error') {
                            statusDiv.textContent = 'Error: ' + data.message;
                        } else if (data.type === 'session_started') {
                            statusDiv.textContent = 'Session started. Start typing!';
                            sessionActive = true;
                            startBtn.disabled = true;
                            endBtn.disabled = false;
                            textInput.focus();
                        } else if (data.type === 'session_ended') {
                            statusDiv.textContent = 'Session ended';
                            sessionActive = false;
                            startBtn.disabled = false;
                            endBtn.disabled = true;
                        }
                    } catch (e) {
                        console.error('Error parsing JSON:', e);
                    }
                } else {
                    // Binary audio data
                    const audioBlob = new Blob([event.data], { type: 'audio/mp3' });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    
                    // Add to queue and play if not already playing
                    audioQueue.push(audioUrl);
                    if (!isPlaying) {
                        playNextInQueue();
                    }
                }
            };
        }
        
        function playNextInQueue() {
            if (audioQueue.length === 0) {
                isPlaying = false;
                return;
            }
            
            isPlaying = true;
            const audioUrl = audioQueue.shift();
            
            // Create audio element
            const audio = new Audio(audioUrl);
            currentAudioElement = audio;
            
            // Clean up previous audio elements to avoid memory leaks
            while (audioContainer.firstChild) {
                const oldUrl = audioContainer.firstChild.src;
                URL.revokeObjectURL(oldUrl);
                audioContainer.removeChild(audioContainer.firstChild);
            }
            
            audioContainer.appendChild(audio);
            
            audio.onended = function() {
                URL.revokeObjectURL(audioUrl);
                playNextInQueue();
            };
            
            audio.onerror = function() {
                console.error('Error playing audio');
                URL.revokeObjectURL(audioUrl);
                playNextInQueue();
            };
            
            audio.play().catch(err => {
                console.error('Error playing audio:', err);
                playNextInQueue();
            });
        }
        
        // Handle text input changes with debounce
        textInput.addEventListener('input', function() {
            if (!sessionActive) return;
            
            clearTimeout(typingTimer);
            
            // Set a timer to send the text after a short delay
            typingTimer = setTimeout(function() {
                const currentText = textInput.value;
                const newText = currentText.substring(lastSentText.length);
                
                if (newText.length > 0) {
                    // Send only the new text
                    const data = {
                        type: 'add_text',
                        text: newText
                    };
                    console.log("Sending:", JSON.stringify(data));
                    socket.send(JSON.stringify(data));
                    
                    lastSentText = currentText;
                }
            }, 100); // 100ms debounce
        });
        
        startBtn.addEventListener('click', function() {
            initAudioContext();
            
            // Clear any existing audio
            audioQueue = [];
            if (currentAudioElement) {
                currentAudioElement.pause();
                currentAudioElement = null;
            }
            
            while (audioContainer.firstChild) {
                const oldUrl = audioContainer.firstChild.src;
                URL.revokeObjectURL(oldUrl);
                audioContainer.removeChild(audioContainer.firstChild);
            }
            
            // Reset text tracking
            textInput.value = "";
            lastSentText = "";
            
            // Start a new session
            const data = {
                type: 'start_session',
                language: languageSelect.value
            };
            console.log("Sending:", JSON.stringify(data));
            socket.send(JSON.stringify(data));
        });
        
        endBtn.addEventListener('click', function() {
            // End the current session
            const data = {
                type: 'end_session'
            };
            console.log("Sending:", JSON.stringify(data));
            socket.send(JSON.stringify(data));
            
            endBtn.disabled = true;
            sessionActive = false;
        });
        
        // Connect when the page loads
        window.addEventListener('load', connectWebSocket);
    </script>
</body>
</html> 